// Pipeline parameters
params {

    // General defaults
    errorStrategy = 'ignore'
    monochrome_logs = null
    diagnostics = null
    prefix = null
    readQualityScore = 20
    help = null
    force = null

    // Directory defaults
    options.output = "./results"
    options.resultsDir = "${options.output}/Sample_Files/"
    options.reportsDir = "${options.output}/report/"

    // Assay defaults
    rna = null    
    atac = null
    catac = null

    preset{
        rna{
            includeConfig 'conf/rna_preset.config'
        }        

        atac{
            includeConfig 'conf/atac_preset.config'
        }
    }

    // Barcode defaults
    barcode.force = null

    // Resource defaults
    maxCpus = 64
    maxMemory = '500.GB'
    maxTime = '12h'

}

manifest {

    name = 'BioRadOpenSource/omnition'
    description = 'Bio-Rad Omnition analysis software for single-cell data.'
    defaultBranch = 'main'
    mainScript = 'main.nf'
    nextflowVersion = '!>=22.04.0, <=23.10.1'
    version = 'v1.1.0'
    recurseSubmodules = true

}


// Process management settings
process {

    // Cache based on contents
    cache = 'lenient'
    withName: SINGULARITY_PULL {
        cache = false
    }

    // Setting error strategy 
    // 134 = Program aborted
    // 104, 137, 143 = Out of memory
    // 139 = Segfault
    errorStrategy = { task.exitStatus in [104,134,137,139,143] ? 'retry' : params.errorStrategy }
    maxRetries = 2
    maxErrors = -1

    // Dynamic resource configurations
    withLabel: memory_xxsmall {
        memory = { check_max( 0.9375.GB * ( 2 ** ( task.attempt - 1 ) ), 'memory' ) }
        time = { check_max(12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }
    withLabel: memory_xsmall {
        memory = { check_max( 3.75.GB * ( 2 ** ( task.attempt - 1 ) ), 'memory' ) }
        time = { check_max(12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }
    withLabel: memory_small {
        memory = { check_max( 7.5.GB * ( 2 ** ( task.attempt - 1 ) ), 'memory' ) }
        time = { check_max( 12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }
    withLabel: memory_medium {
        memory = { check_max( 15.GB * ( 2 ** ( task.attempt - 1 ) ), 'memory' ) }
        time = { check_max( 12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }
    withLabel: memory_large {
        memory = { check_max( 30.GB * ( 2 ** ( task.attempt - 1 ) ), 'memory' ) }
        time = { check_max( 12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }
    withLabel: memory_xlarge {
        memory = { check_max( 60.GB * ( 2 ** ( task.attempt - 1 ) ), 'memory' ) }
        time = { check_max( 12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }
    withLabel: memory_xxlarge {
        memory = { check_max( 120.GB * ( 2 ** ( task.attempt - 1 ) ), 'memory' ) }
        time = { check_max( 12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }
    withLabel: memory_xxxlarge {
        memory = { check_max( 250.GB * ( 2 ** ( task.attempt - 1 ) ), 'memory' ) }
        time = { check_max( 12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }

    withLabel: cpu_xsmall {
        cpus = { check_max( 1 ,'cpus' ) }
        time = { check_max(12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }
    withLabel: cpu_small {
        cpus = { check_max( 2 ,'cpus' ) }
        time = { check_max(12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }
    withLabel: cpu_medium {
        cpus = { check_max( 4 ,'cpus' ) }
        time = { check_max(12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }
    withLabel: cpu_large {
        cpus = { check_max( 8, 'cpus' ) }
        time = { check_max( 12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }
    withLabel: cpu_xlarge {
        cpus = { check_max( 16, 'cpus' ) }
        time = { check_max( 12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }
    withLabel: cpu_xxlarge {
        cpus = { check_max( 32, 'cpus' ) }
        time = { check_max( 12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }
    withLabel: cpu_xxxlarge {
        cpus = { check_max( 64, 'cpus' ) }
        time = { check_max( 12.h * ( 2 ** ( task.attempt - 1 ) ), 'time' ) }
    }

    withName: UMI_TOOLS_COUNT {
        time = '30h'
    }

    withName: AGGREGATE_METRICS {
        time = '30h'
    }
}


// Execution profiles for defining container system settings
profiles {

    standard {
        singularity.enabled = true
        singularity.autoMounts = true
        singularity.cacheDir = "${projectDir}/singularity/"
    }
    
    docker {
        docker.enabled = true
        docker.fixOwnership = true
        docker.runOptions = "--shm-size 16g"
    }

    awsbatch {
        includeConfig 'conf/aws.config'
    }

    tower {
        includeConfig 'conf/tower.config'
    }

    demo_atac { 
        includeConfig 'conf/test.config' 
    }

    demo_catac { 
        includeConfig 'conf/test.config' 
    }       
    
    demo_rna_single {
        includeConfig 'conf/test.config'
    }

    demo_rna_mixed_options {
        includeConfig 'conf/test.config'
    }

}

if (params.rna != null) {
    params.options.output = params.rna.get('output') ?: "./results";
} else if (params.atac != null) {
    params.options.output = params.atac.get('output') ?: "./results";
} else if (params.catac != null) {
    params.options.output = params.catac.get('output') ?: "./results";
}


// Get the full command line string and parse for the profile information for non-smoke_tests
if ((System.getenv().NXF_CLI.findAll(/-profile +\S+/)[0]?.split(",").findAll { it.contains("tower") })
    && (System.getenv().NXF_CLI.findAll(/-profile +\S+/)[0]?.split(",").findAll { it.contains("demo") })
    && (System.getenv().NXF_CLI.findAll(/-name +\S+/)[0]?.split(",").find { it.contains("PR") }?.findAll(/PR-+\S+_demo_+\S+/)?[0] == null)) {
    demo_profile = System.getenv().NXF_CLI.findAll(/-profile +\S+/)[0].split(",").find { it.contains("demo") }.findAll(/demo+\S+/)[0]
    current_date = String.format('%tF_%<tT', java.time.LocalDateTime.now())
    params.options.output = params.tower.aws_work_bucket+"demo_data_results/${demo_profile}/${current_date}"
}

params.options.resultsDir = "${params.options.output}/Sample_Files/"
params.options.reportsDir = "${params.options.output}/report/"


// Grab CLI params-file info
// Accessing parsed parameters variable via nextflow 
// https://github.com/nextflow-io/nextflow/blob/master/modules/nextflow/src/main/groovy/nextflow/config/ConfigParser.groovy#L98
params.options.paramsFile = paramVars

// Check to see if the Seqera Platform output path is valid for non-demo profile runs
if ((System.getenv().NXF_CLI.findAll(/-profile +\S+/)[0]?.split(",").findAll { it.contains("tower") }) 
    && !(System.getenv().NXF_CLI.findAll(/-profile +\S+/)[0]?.split(",").findAll { it.contains("demo") })) {
    if ((params.options.output.find("s3://") != null) && (System.getenv().NXF_CLI.findAll(/-name +\S+/)?.find { it.contains("qcp_analysis") } == null)) {
        outpath = params.options.output.split("s3://dbg-lab-dev-sequencing/analysis/")
        if ((outpath.size() == 0) || (outpath[0] != "")) {
            System.out.println("Invalid output path: $params.options.output")
            System.exit(1)
        }
    }
}

def trace_timestamp = new java.util.Date().format( 'yyyyMMdd-HHmmss')
report {
    enabled = true
    file = params.prefix ? "${params.options.output}/pipeline_info/${params.prefix}-omnition-execution_report-${trace_timestamp}.html" : "${params.options.output}/pipeline_info/omnition-execution_report-${trace_timestamp}.html"
}
timeline {
    enabled = true
    file = params.prefix ? "${params.options.output}/pipeline_info/${params.prefix}-omnition-timeline-${trace_timestamp}.html" : "${params.options.output}/pipeline_info/omnition-timeline-${trace_timestamp}.html"
}
trace {
    enabled = true
    fields = "task_id,hash,native_id,name,status,exit,submit,duration,realtime,cpus,%cpu,peak_rss,peak_vmem,rchar,wchar"
    file = params.prefix ? "${params.options.output}/pipeline_info/${params.prefix}-omnition-trace-${trace_timestamp}.txt" : "${params.options.output}/pipeline_info/omnition-trace-${trace_timestamp}.txt"
}
dag {
    enabled = true
    file = params.prefix ? "${params.options.output}/pipeline_info/${params.prefix}-omnition-dag-${trace_timestamp}.html" : "${params.options.output}/pipeline_info/omnition-dag-${trace_timestamp}.html"
}


// Function for comparing resource requests to available resources
def check_max(obj, type) {
    if (type == 'cpus') {

        try {
            return Math.min( obj, params.maxCpus as int )
        } catch (all) {
            println "[ERROR] Max cpus '${params.maxCpus}' is not valid. Using default value: $obj"
            return obj
        }

    } else if (type == 'memory') {

        try {
            if (obj.compareTo(params.maxMemory as nextflow.util.MemoryUnit) == 1)
                return params.maxMemory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "[ERROR] Max memory '${params.maxMemory}' is not valid. Using default value: $obj"
            return obj
        }

    } else if (type == 'time') {

        try {
            if (obj.compareTo(params.maxTime as nextflow.util.Duration) == 1)
                return params.maxTime as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "[ERROR] Max time '${params.maxTime}' is not valid. Using default value: $obj"
            return obj
        }
    }
}
