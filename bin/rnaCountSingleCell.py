#!/usr/bin/env python3

import pysam
import ray
import pandas as pd
from ray.exceptions import ObjectStoreFullError
from pathlib import Path
from pathlib import PurePath
from coreBamCounter import getChromosomesWithAlignments
import click
import sys


@click.command()
@click.option("--input_bam", "-i", help="A .bam file with an index.")
@click.option(
    "--barcode-tag",
    "-bt",
    default="XC",
    help="Tag in the .bam file that points to the barcode.",
)
@click.option(
    "--umi-tag",
    "-ut",
    default="XM",
    help="Tag in the .bam file that points to the UMI.",
)
@click.option(
    "--gene-tag",
    "-gt",
    default="XT",
    help="Tag in the .bam file that points to the gene symbol.",
)
@click.option(
    "--feature-tag", "-ft", default="XF", help="Tag containing the genome feature."
)
@click.option(
    "--cpus", "-c", default=1, help="The number of CPUs for parallel processing."
)
@click.option(
    "--min-mapq",
    "-m",
    default=0,
    help="Include alignments at or above this mapping quality.",
)
@click.option(
    "--mito-contig",
    "-mt",
    default="MT",
    multiple=True,
    help="The mitochondrial contig; multiple -mt options accepted.",
)
@click.option(
    "--ribosomal-interval",
    "-ri",
    help="Ribosomal interval list with IDs and locations of rRNA regions.",
)
@click.option(
    "--species-mix",
    "-sm",
    default=False,
    help="Whether the experiment is a species mix.",
)
@click.option(
    "--species-id-1",
    "-si1",
    default=None,
    help="Prefix for species one in species mix experiments.",
)
@click.option(
    "--species-id-2",
    "-si2",
    default=None,
    help="Prefix for species two in species mix experiments.",
)
@click.option(
    "--out-path",
    "-o",
    default="./",
    help="Output path; defaults to location of .bam file input.",
)
def main(
    input_bam,
    barcode_tag,
    umi_tag,
    gene_tag,
    feature_tag,
    cpus,
    out_path,
    min_mapq,
    mito_contig,
    ribosomal_interval,
    species_mix,
    species_id_1,
    species_id_2,
):
    chroms2use = getChromosomesWithAlignments(input_bam)
    rrna = readRibosomalIntervalList(ribosomal_interval)
    ray.init(num_cpus=cpus)
    try:
        contig_cols = ray.get(
            [
                countScrnaSE.remote(
                    input_bam,
                    chrom,
                    barcode_tag,
                    umi_tag,
                    gene_tag,
                    feature_tag,
                    min_mapq,
                    mito_contig,
                    rrna,
                    species_mix,
                    species_id_1,
                    species_id_2,
                    out_path,
                )
                for chrom in chroms2use
            ]
        )
    except ObjectStoreFullError:
        ray.shutdown()
        print("OOM error: ObjectStoreFullError")
        sys.exit(137)
    except Exception as err:
        ray.shutdown()
        print(f"Unexpected {err=}, {type(err)=}")
        sys.exit(1)
    d = postProcessScrnaSE(contig_cols)
    if out_path == "":
        out_dir = Path(input_bam).parents[0]
    else:
        out_dir = Path(out_path)
    out_file = PurePath(input_bam).name.replace("bam", "scrnaseq_counts.csv")
    out_dir.mkdir(parents=True, exist_ok=True)
    d.to_csv("{}/{}".format(out_dir, out_file), index=False)

    ray.shutdown()


def readRibosomalIntervalList(ribosomal_interval):
    # Importing the interval list file (skips SQL line)
    interval_df = pd.read_table(
        ribosomal_interval,
        skiprows=1,
        names=["chr", "start", "stop", "strand", "gene_id"],
    )

    # Extracting the gene_id column as a list for matching
    gene_id_list = interval_df["gene_id"].str.replace('gene_id |"', "").tolist()

    return gene_id_list


def postProcessScrnaSE(contig_cols):
    """
    process a list of dictionaries generated by countScrnaSE into a table
    Each item in the list is a dictionary of results parsed from one contig """\
    """in the reference genome
    Each item in each chromosome's dictionary is a per-barcode dictionary
    Each per-barcode dictionary is composed of a 'meta' and 'genes' key
    The 'meta' dictionary contains counts of 'keys' defined in countScrnaSE
    The 'genes' dictionary contains the actual UMI for each gene
    """

    out_df = (
        pd.concat(contig_cols)
        .groupby(["barcode"])
        .sum()
        .reset_index()
        .sort_values(by="transcripts", ascending=False)
        .fillna(value=0)
    )

    return out_df


@ray.remote
def countScrnaSE(
    bam,
    chrom,
    barcode_tag,
    umi_tag,
    gene_tag,
    feature_tag,
    min_mapq,
    mito_contig,
    rrna,
    species_mix,
    species_id_1,
    species_id_2,
    out_path,
):
    """
    Counts per barcode the:
    """
    keys = [
        "input_reads",
        "genes",
        "umi",
        "transcripts",
        "genic_reads",
        "coding_reads",
        "utr_reads",
        "intronic_reads",
        "intergenic_reads",
        "rRNA_reads",
        "mitochondrial_reads",
        "unassigned_ambiguous_reads",
        "unassigned_low_mapping_qual_reads",
        "unassigned_other_reads",
    ]

    if species_mix:
        keys = keys + [
            f"input_{species_id_1}_reads",
            f"input_{species_id_2}_reads",
            f"{species_id_1}_umi",
            f"{species_id_2}_umi",
        ]

    bamFile = pysam.AlignmentFile(bam, "rb")
    Itr = bamFile.fetch(chrom, multiple_iterators=True, until_eof=False)
    dic = {}

    if (species_mix):
        species_id = chrom.split(".")[0]  # mixed species
        species_mix = True
    else:
        species_id = None
        species_mix = False

    for read in Itr:
        # check for a gene/assignment, barcode, umi, mapq, primary
        countable_read = [
            read.has_tag(gene_tag),
            read.has_tag(barcode_tag),
            read.has_tag(umi_tag),
            read.mapping_quality >= min_mapq,
            read.is_secondary is False,
        ]

        if all(countable_read):
            # if yes, start a record for the barcode if it does not exist

            barc = read.get_tag(barcode_tag)

            if dic.get(barc) is None:
                dic[barc] = {}
                dic[barc]["meta"] = {key: 0 for key in keys}
                dic[barc]["genes"] = {}

            # count the read
            dic[barc]["meta"]["input_reads"] += 1
            if species_mix:
                dic[barc]["meta"][f"input_{species_id}_reads"] += 1

            # now the logic for assigning the read to one of the above groups
            assignment = read.get_tag(gene_tag)

            # get the umi
            umi = read.get_tag(umi_tag)

            # genic v. intron v. intergenic read count
            if assignment == "INTRON":
                dic[barc]["meta"]["intronic_reads"] += 1
                dic = update_dict(barc, umi, assignment, species_mix, species_id, dic)

            elif assignment == "INTERGENIC":
                dic[barc]["meta"]["intergenic_reads"] += 1
                dic = update_dict(barc, umi, assignment, species_mix, species_id, dic)

            elif assignment == "Unassigned_MappingQuality":
                dic[barc]["meta"]["unassigned_low_mapping_qual_reads"] += 1

            elif assignment == "Unassigned_Ambiguous":
                dic[barc]["meta"]["unassigned_ambiguous_reads"] += 1

            elif assignment.startswith("Unassigned_"):
                dic[barc]["meta"]["unassigned_other_reads"] += 1

            else:
                # get the gene
                gene = read.get_tag(gene_tag)

                # update counts
                dic[barc]["meta"]["genic_reads"] += 1

                # check if it's rRNA or mitochondrial
                if gene in rrna:
                    dic[barc]["meta"]["rRNA_reads"] += 1
                elif chrom in mito_contig:
                    dic[barc]["meta"]["mitochondrial_reads"] += 1

                # then update the counts dictionary
                dic = update_dict(barc, umi, gene, species_mix, species_id, dic)

                if read.has_tag(feature_tag):
                    feature = read.get_tag(feature_tag)

                    # counts for exons vs UTRs, both are considered genic
                    # Only when including introns as genic reads can "INTRON"
                    # be on feature_tag. Thus, we count it when we see it.
                    # When the pipeline is configured to exclude intronic reads
                    # in gene counts, there will never be "INTRON" on feature_tag.
                    if feature == "EXON":
                        dic[barc]["meta"]["coding_reads"] += 1
                    elif feature == "UTR":
                        dic[barc]["meta"]["utr_reads"] += 1
                    elif feature == "INTRON":
                        dic[barc]["meta"]["intronic_reads"] += 1
    barcodes = []
    while len(dic) > 0:
        # Grab an arbitrary item and remove it from the dictionary
        barcode, value = dic.popitem()
        barcodes.append(
            pd.DataFrame.from_dict(value.get("meta"), orient="index", columns=[barcode])
        )

    cols = pd.concat(barcodes, axis=1)
    del barcodes
    # reconfigure to add column names and sort by nUMI
    cols = (
        cols.transpose()
        .rename_axis("barcode")
        .reset_index()
        .sort_values(by="transcripts", ascending=False)
    )

    return cols


def update_dict(barcode, umi, gene, species_mix, species_id, dic):
    """
    Takes in a barcode, umi, and gene then appropriately updates """\
    """the input dictionary with the count
    """
    # add a count for this barcode, umi, gene tuple to the genes count table
    # if the gene doesn't exist, add it and check if the gene has been seen
    # on this barcode before
    if dic[barcode]["genes"].get(gene) is None:  # if not ...
        dic[barcode]["meta"]["genes"] += 1  # score a count for a new gene
        dic[barcode]["genes"][gene] = []  # create an empty list to store the UMIs
        dic[barcode]["genes"][gene].append(umi)  # add the UMI
        dic[barcode]["meta"]["umi"] += 1  # score a UMI count in the metadata
        if gene not in ["INTERGENIC", "INTRON"]:
            dic[barcode]["meta"]["transcripts"] += 1  # score a new transcript
            if species_mix:
                dic[barcode]["meta"][
                    species_id + "_umi"
                ] += 1  # score a UMI count for the species if a species mix
    # otherwise the gene has been seen on this barcode before due to a key being
    # present in the GENES dictionary
    # if the UMI already exists, however, it's deemed a duplicate and ignored;
    # only UMIs not observed with this gene are counted
    elif umi not in dic[barcode]["genes"].get(gene):
        dic[barcode]["genes"][gene].append(umi)
        dic[barcode]["meta"]["umi"] += 1
        if gene not in ["INTERGENIC", "INTRON"]:
            dic[barcode]["meta"]["transcripts"] += 1
            if species_mix:
                dic[barcode]["meta"][
                    species_id + "_umi"
                ] += 1  # score a UMI count for the species if a species mix
    return dic


if __name__ == "__main__":
    main()
